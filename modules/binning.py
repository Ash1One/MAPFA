#!/usr/bin/env python
# -*- coding: utf-8 -*-

import logging
import os
import pandas as pd
import subprocess
import shutil
from pathlib import Path

from .utils import fileExists, makesurePathExists


def metabat2bin(align_outdir, assembly_file, metabat_minlength, threads, tbam_files):
    '''return the path of bin outdir
    '''

    logger = logging.getLogger('mapfa')
    logger.info("making coverage file for metabat2...")
    depth_path = os.path.join(align_outdir, 'metabat2_depth.txt')
    if fileExists(depth_path):
        os.remove(depth_path)
    cmd_mk_cov = ' '.join(('jgi_summarize_bam_contig_depths', ' --outputDepth',
                           depth_path) + tbam_files)
    logger.info("Command: %s", cmd_mk_cov)
    try:
        subprocess.run(cmd_mk_cov, shell=True, check=True)
    except Exception:
        logger.critical(
            "Something wrong when making converage file for metabat2.", exc_info=True)
        raise
    else:
        logger.info("Start binning with metabat2...")
        metabat2_bin_out = os.path.join(
            os.path.dirname(align_outdir), 'metabat2_bins', 'bin')
        cmd_metabat2 = ' '.join(['metabat2', '-t', str(threads), '-i', assembly_file, '-a', os.path.join(
            align_outdir, 'metabat2_depth.txt'), '-o', metabat2_bin_out, '-m', str(metabat_minlength), '--unbinned'])
        logger.info("Command: %s", cmd_metabat2)
        try:
            subprocess.run(cmd_metabat2, shell=True, check=True)
        except Exception:
            logger.critical(
                "Something wrong when binning with metabat2...", exc_info=True)
            raise
        else:
            metabat2_bin_outdir = os.path.join(
                os.path.dirname(align_outdir), 'metabat2_bins')
            num_bins = len(list(Path(metabat2_bin_outdir).glob('bin*.fa')))
            logger.info(
                "Success! Total %d bins were generated by metabat2.", num_bins)
            return metabat2_bin_outdir


def maxbin2bin(align_outdir, assembly_file, minlength, threads, tbam_files):
    logger = logging.getLogger('mapfa')
    logger.info("making coverage file for maxbin2...")
    depth_path = os.path.join(align_outdir, 'maxbin2_depth.txt')
    if fileExists(depth_path):
        os.remove(depth_path)
    cmd_mk_cov = ' '.join(('jgi_summarize_bam_contig_depths', ' --outputDepth', depth_path + '--noIntraDepthVariance') + tbam_files)
    try:
        subprocess.run(cmd_mk_cov, shell=True, check=True)
    except Exception:
        logger.critical(
            "Something wrong when making converage file for maxbin2.", exc_info=True)
        raise
    else:
        # cut maxbin2_depth to depth files for different samples.
        depth = pd.read_table(depth_path)
        maxbin2_abundant = []
        for col in depth.columns[3:]:
            abundant_file = 'maxbin2_'+col.replace('bam', 'txt')
            depth.loc[:, ['contigName', col]].to_csv(
                abundant_file, sep='\t', header=False, index=False)
            maxbin2_abundant.append(abundant_file)

        with open(os.path.join(align_outdir, 'maxbin2_abundant.txt'), 'w') as f:
            for file in maxbin2_abundant:
                f.write(os.path.abspath(file))
                f.write('\n')

    # run_MaxBin.pl
    run_Maxbin = subprocess.run('run_MaxBin.pl', shell=True, check=True, stdout=subprocess.PIPE)
    if not run_Maxbin.stdout.decode('utf-8'):
        logger.critical("Something wrong when running run_Maxbin.pl, please check if perl was setted correctly.")
        return False
    logger.info("Start binning with maxbin2...")
    maxbin2_out = os.path.join(align_outdir, 'maxbin2_out', 'bin')
    cmd_maxbin2 = ' '.join(['run_MaxBin.pl', '-contig', assembly_file, '-out', maxbin2_out, '-abund_list', os.path.join(align_outdir, 'maxbin2_abundant.txt'), '-min_contig_length', str(minlength), '-thread', str(threads)])
    try:
        subprocess.run(cmd_maxbin2, shell=True, check=True)
    except Exception:
        logger.critical("Something wrong when binning with maxbin2...", exc_info=True)
        raise

    maxbin2_bin_dir = os.path.join(os.path.dirname(align_outdir), 'maxbin2_bins')
    makesurePathExists(maxbin2_bin_dir)
    bin_num = 0
    for bin_path in list(Path(align_outdir).joinpath('maxbin2_out').glob('bin*.fasta')):
        shutil.copy(str(bin_path), os.path.join(maxbin2_bin_dir, 'bin.'+str(bin_num)+'.fasta'))
        bin_num += 1
    logger.info("Success! Total %d bins were generated by maxbin2.", bin_num)
    return maxbin2_bin_dir

def groopm2bin():
    pass


def concoct2bin():
    pass
